一个进程中当多线程的去竞争某一资源的时候，我们通常会用一把锁来保证只有一个线程获取到资源。如果是多个进程相互竞争一个资源，会保证资源只会被一个操作者持有。

redis的String类型就可以实现。

#### 锁的获取

setnx命令：表示SET if Not eXists，即如果 key 不存在，才会设置它的值，否则什么也不做。

例如：两个客户端同时向redis写入try_lock（`setnx try_lock 1`），客户端1写入成功，即获取分布式锁成功。客户端2写入失败，则获取分布式锁失败。

#### 锁的释放

当客户端1操作完后，释放锁资源，即删除try_lock(`del try_lock`)。那么此时客户端2再次尝试获取锁时，则会获取锁成功。

#### 避免死锁

假如客户端1在获取到锁资源后，服务宕机了，那么这个try_lock会一直存在redis中，那么其他服务就永远无法获取到锁了。

设置键过期时间，超过这个时间即给key删除掉。这样的话，就算当前服务获取到锁后宕机了，这个key也会在一定时间后被删除，其他服务照样可以继续获取锁。

`set serverLock 1 ex 10 nx` 给serverLock键设置一个10秒的过期时间，10秒后会自动删除该键。

#### 锁的续期

虽然可以通过增加删除key时间来处理这个问题，但是并没有从根本上解决。假设设个100s，绝大多数都是1s后就会释放锁，但是由于服务宕机，则会导致100s内其他服务都无法获取到锁，这也是灾难性的。

我们可以这样做，在锁将要过期的时候，如果服务还没有处理完业务，那么将这个锁再续一段时间。比如设置key在10s后过期，那么再开启一个守护线程，在第8s的时候检测服务是否处理完，如果没有，则将这个key再续10s后过期。

获取锁后启动watch dog(看门狗) 的自动延期机制。watch dog 机制可由try、catch、finally 和while循环实现。

```php
try {
    // 可能抛出异常的代码
    // 例如，打开文件、执行数据库查询等
    // 如果发生异常，将会抛出异常对象
} catch (ExceptionType1 $e) {
    // 处理 ExceptionType1 类型的异常
    // 可以访问异常对象 $e 的属性和方法
} catch (ExceptionType2 $e) {
    // 处理 ExceptionType2 类型的异常
} finally {
    // 执行清理操作的代码
    // 无论是否有异常，都会执行该块的代码
}
```

在上面的代码中，你需要将 "ExceptionType1" 和 "ExceptionType2" 替换为你要捕获的具体异常类型。你可以根据需要添加更多的 catch 块来处理其他类型的异常。

在 catch 块中，你可以使用异常对象的属性和方法来获取有关异常的信息，例如异常消息、文件、行号等。

无论是否发生异常，finally 块中的代码都会被执行。它是可选的，可以根据你的需求决定是否使用它。

- 如果 catch 里面有 return 或者 try 里面有 return，finally 里面没有 return，最后会 return 前面的第一个 return，非 finally 代码段的 return 后面的代码是不执行的，finally 代码段肯定会执行。
- 如果 catch 里面有 return 或者 try 里面有 return，finally 里面有 return，非 finally 代码段的 return 后面的代码是不执行的，但是 finally 里面的 return 会覆盖前面 return 的值

#### RedLock

在Redis的分布式环境中，我们假设有N个Redis Master。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**，官方相关文档：[REDIS distlock](http://redis.cn/topics/distlock.html)

我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。

为了取到锁，客户端应该执行以下操作:

1. 获取当前Unix时间，以毫秒为单位T1。
2. 依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。
3. 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间T1）就得到获取锁使用的时间。当且仅当从大多数（这里是大于等于3个节点时间T2）的Redis节点都取到锁，并且使用的时间小于锁失效时间时（T2 - T1 < 锁的过期时间），锁才算获取成功。
4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
5. 如果因为某些原因，获取锁失败（*没有*在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。
