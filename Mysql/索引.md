> #### MySQL 官方对索引的定义是：索引（Index）是帮助 MySQL 高效获取数据的数据结构。索引最形象的比喻就是图书的目录。注意只有在大量数据中查询时索引才显得有意义。
>
> #### 在 MySQL 中索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。常见的索引分类如下：
>
> - 按数据结构分类：B+tree 索引、Hash 索引、Full-text 索引。
> - 按物理存储分类：聚集索引、非聚集索引（也叫二级索引、辅助索引）。
> - 按字段特性分类：主键索引(PRIMARY KEY)、唯一索引(UNIQUE)、普通索引(INDEX)、全文索引(FULLTEXT)。
> - 按字段个数分类：单列索引、联合索引（也叫复合索引、组合索引）。

## 按数据结构分类：

| 类型           | InnoDB          | MyISAM | Memory |
| :------------- | :-------------- | :----- | :----- |
| B+tree 索引    | √               | √      | √      |
| Hash 索引      | ×               | ×      | ×      |
| Full-text 索引 | √（MySQL5.6.4） | √      | √      |

> 注：InnoDB 实际上也支持 Hash 索引，但是 InnoDB 中 Hash 索引属于是自适应 Hash 索引，它的创建过程由存储引擎引擎自动优化创建，不能人为干预是否为表创建 Hash 索引

#### Hash 索引

1. **Hash 索引仅仅能满足等值查询，不能进行范围查询**（由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和 Hash 运算前完全一样。）
2. **Hash 索引无法通过操作索引来排序**（由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且 Hash 值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。）
3. **组合 Hash 索引不能利用部分索引键进行查询**（对于组合 Hash 索引，索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。）
4. **Hash 索引依然需要回表扫描**（Hash 索引是将索引键通过 Hash 运算之后，将 Hash 运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键可能存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。）
5. **Hash 索引遇到大量 Hash 值相等的情况后性能并不一定就会比 B+Tree 索引高**（区分度低的索引键（如，性别），如果创建 Hash 索引，那么将会存在大量记录指针信息与同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。）

#### Full-text 索引

```sql
// 查询语法
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```

#### **聚簇索引**（数据和索引一起的叫做聚簇索引）

> InnoDB 表要求必须有聚簇索引，`默认在主键字段上建立聚簇索引`，在`没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引`，在`前两者都没有的情况下，InnoDB将自动生成一个隐式的自增id列，并在此列上建立聚簇索引`。

#### **非聚集索引**（也叫二级索引、辅助索引）

> 非聚集索引的结构和聚集索引基本相同（非叶子结点存储的都是索引指针），区别在于叶子节点存放的不是行数据而是数据主键。因此在使用非聚集索引进行查找时，需要先查找到主键值，然后再到聚集索引中进行查找。

两种索引的区别：每个索引上包含的字段内容不同，聚集索引包含所有真实的物理数据，非聚集索引只包含索引字段和主键字段。此外，聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。

**那非聚集索引这种查询方式算不算回表呢？**

回表查询简单来说就是通过非聚集索引查询数据时，得不到完整的数据内容，需要再次查询主键索引来获得数据内容。

所以如果使用非聚集索引后还需要使用其他字段的（包括在 where 条件中或者 select 子句中），则需要通过主键索引回表到聚集索引获取其他字段。如果是非聚集索引可以满足 SQL 语句的所有字段的，则被称为全覆盖索引，没有回表开销。

避免回表查询问题，常见的方式就是建立联合索引（组合索引），实现索引覆盖，从而避免回表查询。索引覆盖就是指索引的叶子节点已经包含了查询的数据，满足查询要求，没必要再回表进行查询。

#### 主键索引(PRIMARY KEY)

> 建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。

#### 唯一索引(UNIQUE)

> 建立在 UNIQUE 字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。

#### 普通索引(INDEX)

> 建立在普通字段上的索引被称为普通索引。

#### 全文索引(FULLTEXT)

> MyISAM 存储引擎支持 Full-text 索引，用于查找文本中的关键词，而不是直接比较是否相等。Full-text 索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持 Full-text 索引。

#### 单列索引

> 建立在单个列上的索引被称为单列索引。

#### 联合索引（复合索引、组合索引）

> 建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。在 MySQL 中使用联合索引时要遵循`最左前缀匹配原则`。

1. 实际业务场景中创建联合索引时，我们应该把识别度比较高的字段放在前面，提高索引的命中率，充分的利用索引。
2. 创建联合索引后，该索引的任何最左前缀都可以用于查询。比如当你有一个联合索引(col1, col2, col3)，该索引的所有最左前缀为(col1)、(col1, col2)、(col1, col2, col3)，包含这些列的所有查询都会使用该索引进行查询。
3. 虽然联合索引可以避免回表查询，提高查询速度，但同时也会降低表数据更新的速度。因为联合索引列更新时，MySQL 不仅要保存数据，还要维护索引文件。所以不要盲目过多创建，应根据业务需求来创建。

   （1）**回表**：从某一个索引的叶子结点中获取聚簇索引的 id 值，根据 id 再去聚簇索引中获取全量记录
   （2）**索引覆盖**：从索引的叶子结点能获取到全量查询列的过程叫做索引覆盖

### **3.** **索引的设计原则**

#### **3.1** **哪些情况适合创建索引**

**1.** **字段的数值有唯一性的限制**

索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果`某个字段是唯一的`，就可以直接`创建唯一性索引`，或者`主键索引`。这样可以更快速地通过该索引来确定某条记录。

> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）
>
> 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。

**2.** **频繁作为** **WHERE** **查询条件的字段**

某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。

**3.** **经常** **GROUP BY** **和** **ORDER BY** **的列**

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要`对分组或者排序的字段进行索引`。如果待排序的列有多个，那么可以在这些列上建立`组合索引`。

**4. UPDATE、DELETE** **的** **WHERE** **条件列**

对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。**如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。**

**5.DISTINCT** **字段需要创建索引**

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

**6.** **多表** **JOIN** **连接操作时，创建索引注意事项**

首先，`连接表的数量尽量不要超过 3 张`，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。

其次，`对 WHERE 条件创建索引`，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。

最后，`对用于连接的字段创建索引`，并且该字段在多张表中的`类型必须一致`。

**7.** **使用列的类型小的创建索引**

我们这里所说的`类型大小`指的就是该类型表示的数据范围的大小。

- 数据类型越小，在查询时进行的比较操作越快
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以`放下更多的记录`，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的`主键来说更加适用`，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的 I/O。

**8.** **使用字符串前缀创建索引**

区分度计算公式：

```mysql
count(distinct left(列名, 索引长度))/count(*)
```

**拓展：Alibaba《Java 开发手册》**

【`强制`】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会`高达 90% 以上`。

**9.** **区分度高(散列性高)的列适合作为索引**

`列的基数`指的是某一列中不重复数据的个数，比方说某个列包含值`2,5,8,2,5,8,2,5,8`，虽然有`9`条记录，但该列的基数却是`3`。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。

可以使用公式`select count(distinct a)/count(*) from t1`计算区分度，越接近 1 越好，一般超过`33%`就算是比较高效的索引了。

拓展：联合索引把区分度高（散列性高）的列放在前面。

**10.** **使用最频繁的列放到联合索引的左侧**

**11.** **在多个字段都要创建索引的情况下，联合索引优于单值索引**

##### **3.2** **限制索引的数目**

在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量`不超过6个`。原因：

- 每个索引都需要占用`磁盘空间`，索引越多，需要的磁盘空间就越大。
- 索引会影响`INSERT、DELETE、UPDATE等语句的性能`，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
- 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的`索引来进行评估`，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能。

##### **3.3** **哪些情况不适合创建索引**

**1.** **在 where 中使用不到的字段，不要设置索引**

**2.** **数据量小的表最好不要使用索引**

**3.** **有大量重复数据的列上不要建立索引**

**4.** **避免对经常更新的表创建过多的索引**

**5.** **不建议用无序的值作为索引**

例如身份证、UUID(在索引比较时需要转为 ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。

**6.** **删除不再使用或者很少使用的索引**

**7.** **不要定义冗余或重复的索引**
