### 通常数据库的性能瓶颈在 io 上

1.InnoDB 存储引擎中，主键尽量避免使用很长的字段

> 主键过长，会使得二级索引占用空间过大，从而每页能存放的索引数量变小，导致 io 次数变多。

2.在保障索引分区度的情况下，被索引的字段尽量不要太长

> 索引区分度计算:`SELECT COUNT(DISTINCT(LEFT(字段, 索引长度))) / COUNT(*) AS selectiviti FROM 数据表`，得分的值越大，表示区分度越高。
> 索引字段太长，影响 io 性能。

3.查询中可以使用索引覆盖，避免不必要的回表

> 减少回表，减少 io 次数。

4.不要建立太多的索引

> 建立太多索引，会影响增、删、改等操作的效率。

### 拓展

**为了减少 IO，索引树会一次性加载吗？**

> 1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个 G。
> 
> 2、当我们利用索引查询时候，是不可能将全部几个 G 的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。

**B+树的存储能力如何？为何说一般查找行记录，最多只需 1~3 次磁盘 IO**

> InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT(占用 4 个字节)或 BIGINT(占用 8 个字节)，指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值，因为是估算，为了方便计算，这里的 K 取值为 10^3。也就是说一个深度为 3 的 B+Tree 索引可以维护 10^3 _ 10^3 _ 10^3 = 10 亿条记录。（这里假定一个数据页也存储 10^3 条行记录数据了）
> 
> 实际情况中每个节点可能不能填充满，因此在数据库中，`B+Tree的高度一般都在2~4层`。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作

**为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？**

> 1.B+树的磁盘读写代价更低
> 
> B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。
> 
> 2、B+树的查询效率更加稳定
> 
> 由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

**Hash 索引与 B+树索引的区别**

> 1、Hash 索引`不能进行范围查询`，而 B+树可以。这是因为 Hash 索引指向的数据是无序的，而 B+树的叶子节点是个有序的链表。
> 
> 2、Hash 索引`不支持联合索引的最左侧原则`（即联合索引的部分索引无法使用），而 B+树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。
> 
> 3、Hash 索引`不支持 ORDER BY 排序`，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash 索引进行`模糊查询`，而 B+树使用 LIKE 进行模糊查询的时候，LIKE 后面后模糊查询（比如%结尾）的话就可以起到优化作用。
> 
> 4、`InnoDB不支持哈希索引`
